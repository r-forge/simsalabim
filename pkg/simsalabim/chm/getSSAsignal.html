<html><head><title>Parametric method for identifying trends and periodic components
in SSA decompositions.</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>getSignal(simsalabim)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   getSignal">
<param name="keyword" value="R:   getSignal.decompSSA">
<param name="keyword" value="R:   getTrend">
<param name="keyword" value="R:   getPeriod">
<param name="keyword" value=" Parametric method for identifying trends and periodic components
in SSA decompositions.">
</object>


<h2>Parametric method for identifying trends and periodic components
in SSA decompositions.</h2>


<h3>Description</h3>

<p>
Signal detection algorithm based on ideas of Vautard et.al. (1992) and
Alexandrov (2008a,b)
</p>


<h3>Usage</h3>

<pre>
getSignal(dSSA, ...)
## S3 method for class 'decompSSA':
getSignal(dSSA, omega0=1/dSSA$L,C0,r0,...)
getTrend(U,omega0=1/nrow(U),C0)
getPeriod(U,r0)

</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>dSSA</code></td>
<td>
An object of class <code><a href="decompSSA.html">decompSSA</a></code>.</td></tr>
<tr valign="top"><td><code>omega0</code></td>
<td>
Low frequency boundary.</td></tr>
<tr valign="top"><td><code>C0</code></td>
<td>
Low frequency contribution.</td></tr>
<tr valign="top"><td><code>r0</code></td>
<td>
Dominant frequency contribution.</td></tr>
<tr valign="top"><td><code>U</code></td>
<td>
Matrix of SSA -  Eigenvectors.</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Further arguments to be passed to different methods. </td></tr>
</table>

<h3>Details</h3>

<p>
This signal selection algorithm is based on the fact that the SSA -
Eigenvectors <i>U^i</i> for trends and periodic components have a simple
shape and their periodogram
</p><p align="center"><i>Pi^i(omega) = 1/L |sum_n{exp(-i 2 pi omega n)}
</i></p><p>
is governed by a dominant frequency. (The periodogram is determined by
means of <code><a onclick="findlink('stats', 'fft.html')" style="text-decoration: underline; color: blue; cursor: hand">fft</a></code> and therefore the spacing of <i>omega</i> is
the Nyquist frequency <i>1/L</i>.)
</p>
<p>
The <STRONG><EM>trend</EM></STRONG> extraction is based on the idea that the $U^{(i)}$
contributing to a trend have large periodogram values only for low
frequencies <i>&lt;= omega_0</i>. The contribution of low frequencies is
determined by
</p><p align="center"><i>C(U^i,omega) = sum_{omega &lt;= omega_0}{Pi(omega)} / sum_{omega &lt;=
0.5}{Pi(omega)}
</i></p><p>
<i>U^i</i> are considered to represent a trend component if
<i>C(U^i,omega_0) &lt;= C0</i> (see argument <code>C0</code>).
</p>
<p>
The selection of <STRONG><EM>periodic</EM></STRONG> components is based on the fact that
such components produce pairs of Eigenvalues and Eigenvectors
(<i>U^i</i>, <i>U^i+1</i>). Such pairs have almost
equal eigenvectors and the dominant frequency
</p><p align="center"><i>omega*^i = argmax {Pi(omega)}
</i></p><p>
of the Eigenvectors is similar. This is the case if the following
condition is met:
</p><p align="center"><i>delta^i = | omega*^i - omega*^(i+1) |
</i></p><p>
(As the <i>Pi(omega)</i> is estimated via <code><a onclick="findlink('stats', 'fft.html')" style="text-decoration: underline; color: blue; cursor: hand">fft</a></code>,
<i>delta^i</i> has to be <i>0</i> to fulfill
that criterion, meaning that <i>omega*^i</i> and
<i>omega*^(i+1)</i> are equal.)
</p>
<p>
The above criterion may produce so called "false alarms". Therefore it
is in addition necessary to check whether the Eigenvectors <i>U^i</i>
are really governed by one single frequency. This is done by checking
whether the dominant frequency explains enough of the variance of
<i>Pi(omega)</i>. This is checked by the criterion
</p><p align="center"><i>R^i = max{0.5( gamma^i(omega) + gamma^i(omega + 1/L))}
</i></p><p>
where
</p><p align="center"><i>gamma^i(omega_k) = Pi^i(omega_k)/sum{Pi^i(omega)}   +
Pi^(i+1)(omega_k)/sum{Pi^(i+1)(omega)}
</i></p><p>
The term <i>gamma^i(omega + 1/L)</i>
is to account for smearing of the periodogram in the case of signals
with frequencies that are not multiples of
<i>1/L</i>. <i>U^i</i> and <i>U^(i+1)</i> are
considered to represent a quasi periodic  component if <i>R^i &lt;= r_0</i> (see argument <code>r0</code>).
</p>
<p>
If SSA Eigenelements are detected as contributing to the trend and the
(quasi) periodic components they are only assigned to the periodicities.
</p>


<h3>Value</h3>

<p>
An object of class <EM>SSAsignal</EM>
</p>
<table summary="R argblock">
<tr valign="top"><td><code>periodic</code></td>
<td>
A (possibly empty) data.frame. Each row is associated
with a quasi periodic component, containing the following informations in its columns:
begin{itemize}
<dt><STRONG><code>k1</code></STRONG>,<STRONG><code>k2</code></STRONG></dt><dd>The rank of the Eigenelements
contributing to the quasi periodic component</dd>
<dt><STRONG><code>freq</code></STRONG></dt><dd>The frequency of the maximal value of the power
spectrum of the corresponding Eigenvectors (dominant frequency).</dd>
<dt><STRONG><code>smoothness</code></STRONG></dt><dd>Approximately the proportion of variance explained
by the dominant frequency.</dd>
<dt><STRONG><code>explainedVariance</code></STRONG></dt><dd>Percentage of the variance explained by the
Eigenvalues with the rank <code>k1</code>,<code>k2</code></dd>
end{itemize}
</td></tr>
<tr valign="top"><td><code>trend </code></td>
<td>
A (possibly empty) data.frame. Each row is associated
with a trend component, containing the following
informations in its columns:
begin{itemize}
<dt><STRONG><code>k</code></STRONG></dt><dd>The rank of the Eigenelements contributing to the trend
component</dd>
<dt><STRONG><code>smoothness</code></STRONG></dt><dd>The proportion of variance explained by the
frequencies <i>&lt;=q</i> <code>omega0</code>.</dd>
<dt><STRONG><code>explainedVariance</code></STRONG></dt><dd>Percentage of the variance explained by the
Eigenvalues with the rank <code>k</code></dd>
end{itemize}
</td></tr>
<tr valign="top"><td><code>trendAndPeriod </code></td>
<td>
A (possibly empty) vector kontaining the rank
numbers of the Eigenelements that have been identified as
contributing to trends and quasi periodic components. These elements
are all considered to correspond to periodicities and are therefore
not listed in <code>trend</code>.</td></tr>
<tr valign="top"><td><code>call </code></td>
<td>
Call of the generating function</td></tr>
</table>

<h3>Author(s)</h3>

<p>
Lukas Gudmundsson
</p>


<h3>References</h3>

<p>
Alexandrov, T. A Method of Trend Extraction Using Singular Spectrum
Analysis ArXiv e-prints, 2008, 804.
</p>
<p>
Alexandrov, T. A method of extraction of quasi-periodic time series
components using Singular Spectrum Analysis 2008.
</p>
<p>
Vautard, R.; Yiou, P. &amp; Ghil, M. Singular-spectrum analysis: a toolkit
for short, noisy chaotic signals Physica D-Nonlinear Phenomena,
Elsevier North-Holland, Inc. New York, NY, USA, 1992, 58, 95-126.
</p>


<h3>See Also</h3>

<p>
<code><a href="decompSSA.html">decompSSA</a></code>, <code><a href="decompSSAM.html">decompSSAM</a></code>,
<code><a href="plot.sdTest.html">plot.sdTest</a></code>,<code><a href="MCSSA.html">MCSSA</a></code>
</p>


<h3>Examples</h3>

<pre>

## Artifitial Time series
set.seed(120)
n &lt;- arima.sim(n=200,alist(ar=0.4))
n &lt;- as.vector(scale(n))
x &lt;- sin(seq(0,20*pi,len=200)) + 0.01*(1:200)
## To enable the interpretation of the eigenvectors
## as a representation of explained variance: remove the mean
xn &lt;- scale(x+n/2,center=TRUE,scale=FALSE)
xn.dc &lt;- decompSSA(xn,L=40)

## Identify signal
## It may happen that no or spurious signals are detected due to noise
(xn.signal &lt;- getSignal(xn.dc,C0=0.85,r0=0.85))

## reconstruct signal (trend and period)
trendInd &lt;- as.numeric(xn.signal$trend[,1])
perInd &lt;- as.numeric(as.matrix(xn.signal$period[,1:2]))
xn.trend &lt;- reconSSA(xn.dc,xn,list(trendInd))
xn.period &lt;- reconSSA(xn.dc,xn,list(perInd))

plot(xn,t="l")
lines(xn.trend,lwd=2,col="red")
lines(xn.period,lwd=2,col="blue")
legend("bottomright",legend=c("Trend","Period","xn"),
lwd=c(2,2,1),col=c("red","blue","black")) 

</pre>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>simsalabim</em> version 0.1-1 <a href="00Index.html">Index]</a></div>

</body></html>
